# 决定存放程序的内存地址

在MBR中，我们需要读取软驱上的程序到内存中。在什么内存上才存放这些程序呢？

1. 不能复制到1M以上的内存，因为A20地址线还没打开，没进入保护模式，不能寻址到1M以上的内存。

2. 不能复制到0x0上的内存，因为BIOS的中断向量在0x0上，而我们又需要int 13h读取磁盘。

在PC机中探测系统物理内存(E820内存探测法)，可知我们可用的内存有

<table>
    <tr>
        <th>起始地址</th>
        <th>结束地址</th>
        <th>长度</th>
    </tr>
    <tr>
        <td>0</td>
        <td>9F7FF</td>
        <td>638KB</td>
    </tr>
    <tr>
        <td>100000</td>
        <td>3FEEFFFF</td>
        <td>1021MB</td>
    </tr>
</table>


BIOS把512字节的MBR读取到0x7c00，我把软驱上的程序复制到内存0x7e00上，大约能复制607KB的程序。

* 软驱上的第0扇区(逻辑扇区号)(MBR)已经复制到0x7c00 上。
* 软驱上的第1扇区~1200扇区(逻辑扇区号)复制到0x7e00上。

# BIOS中读取软驱的中断命令

BIOS磁盘存取功能 《IBM-PC汇编语言程序设计 第2版》p479 《IBM-PC汇编语言程序设计 第5版》p330

> INT 13H

> 输入参数：

> AH 要执行的操作：读、写、检验、格式化。AH = 2表示读磁盘扇区

> AL 扇区数

> CH 柱面/磁道(0为起始号)

> CL 起始扇区号(1为起始号，物理扇区号跟逻辑扇区号不一样)

> DH 磁头号，软盘只有两个磁盘，0或1

> DL 驱动器号

> 驱动器    软驱A   软驱B   硬盘1   硬盘2

> 驱动器号  0H  1H  80H 81H

> EX：BX 数据缓冲区地址

物理扇区 
一个1.44MB软盘包含80个磁道. 磁道编号范围是0~79. 
磁盘有上表面和下表面,当磁头定位到一个磁道的时候,上/下磁头都可以对这个位置的磁道进行读写. 编号(0,1). 每个表面上的某个磁道都被分为18个扇区,编号范围是1~18. 于是,一个磁盘包含80*18*2=2880个扇区. 
逻辑扇区 
将磁盘的2880个扇区,从0开始编号,就得到0~2879编号的逻辑扇区. 
我们定义,逻辑扇区从0磁道开始,先编码0磁头,再编码1磁头;然后开始编码1磁道… 于是，每个磁道就包含了0/1两个磁头，共36个扇区. 
物理扇区转化为逻辑扇区 
对于x磁道,y磁头,z扇区,其逻辑扇区号码 
N = 2*18*x + 18*y + z -1 
 这里x取值范围(0,79).第0磁道表示其前面有0个磁道;第1磁道表示前面有1个磁道.第x磁道表示其前
面有x磁道,因此有2*18*x. 
 这里y从(0,1)取值,如果y=1就表示其前面还有18个磁道.  这里z取值范围是(1,18).最后z-1是因为逻辑扇区从0开始. 
逻辑扇区转化为物理扇区 
下面根据上面的公式,计算对于给定的逻辑扇区N, 如何计算得出x,y,z 
 对公式两侧同时除以2*18,就得到  N/(2*18) = x + y/2 + (z-1)/(2*18) 
因为y/2肯定为0, (z-1)/(2*18)也是0,所以就得到x的值.  对公式两侧同时除以18,就得到  N/18 = (2*x) + y + (z-1)/18 = (2*x + y) + (z-1)/18 
我们已经知道(z-1)/18肯定为0. 对于(2*x + y),当y=1时是奇数，y=0时是偶数。对于这样一个数，我们计算(2*x + y) & 0x1，则这个计算式的值和y的取值一致。所以我们得到了y的计算方式。  对公式两侧同时对18取模，就得到 
N%18 = (2*18*x)%18 + (18*y)%18 + (z-1)%18 = 0 + 0 + (z-1)%18 =(z-1) 
 因为(z-1)一定小于18，所以(z-1)%18=(z-1).于是我们得到z = 1 + N%18

# 读取软驱的函数

在我的虚拟机中，软驱A是1.44MB格式的软驱，一共1440KB字节，共2880个扇区。地址表示为 T/H/S

> T 磁道号 track、cylinder 一共有80个磁道

> H 磁头号 head 一共有2个磁头

> S 扇区号 sector 每个磁道、每个磁头上有18个扇区

我把读取扇区的代码变成一个汇编函数rd_sect，要使用汇编指令call，必须先设置栈地址(设置esp)，否则会出错。栈地址(esp)暂时设置为0x7c00。

下面是rd_sect函数

<pre name="code" class="asm">
#函数名：rd_sect
#功能：读取软驱A上的1个扇区
#参数1：  ES：BX    读取数据存放的目的地址
#参数2：  SI        指定逻辑扇区号    

rd_sect:
    pushw   %ax
    pushw   %dx
    pushw   %cx
    pushw   %bx

    movw    %si,    %ax
    movb    $18,    %bl
    divb    %bl                # al <-- (ax)/(bl) 的商
                               # ah <-- (ax)/(bl）的余数
    incb    %ah                # 因为软驱的物理起始扇区号从1开始，而逻辑扇区号从0开始，所以要增1
    movb    %ah,    %cl        # 起始扇区号，（int 13H ah=02h 中断的参数）
    xorb    %ah,    %ah        #ah=0
    movb    $2,     %bl        #bl=2
    divb    %bl                #al <-- (ax)/(bl)
                               #ah <-- (ax)/(bl）的余数
    movb    %ah,    %dh        # 磁头号,（int 13H ah=02h 中断的参数）
    movb    %al,    %ch        # 磁道号,（int 13H ah=02h 中断的参数）    
    popw    %bx

re_rd: 
    movb    $0x2,   %ah        # 读磁盘中断
    movb    $1,     %al        # 读取1个扇区
    movb    $0x0,   %dl        # 读取软驱A
    int $0x13
    jc re_rd

    popw    %cx
    popw    %dx
    popw    %ax

    ret
</pre>



